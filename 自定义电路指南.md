# ğŸ”§ EOS è‡ªå®šä¹‰ç”µè·¯å’Œè§è¯æŒ‡å—

## ğŸ“ æ–‡ä»¶ä½ç½®
- **æ ¸å¿ƒæ¨¡å—**: `src/custom_circuits.rs`
- **æµ‹è¯•ç¤ºä¾‹**: `src/main.rs` ä¸­çš„ `test_custom_circuit_and_witness()` å‡½æ•°

## ğŸ› ï¸ å¦‚ä½•åˆ›å»ºè‡ªå®šä¹‰ç”µè·¯

### 1. åŸºæœ¬ç”µè·¯åˆ›å»º
```rust
// åˆ›å»ºæ–°ç”µè·¯
let mut circuit = CustomCircuit::<F>::new("æˆ‘çš„ç”µè·¯".to_string());

// æ·»åŠ ç§æœ‰è§è¯ï¼ˆç§˜å¯†è¾“å…¥ï¼‰
let x_idx = circuit.add_private_witness(F::from(3u64));
let y_idx = circuit.add_private_witness(F::from(4u64));

// æ·»åŠ å…¬å¼€è¾“å…¥ï¼ˆéªŒè¯è€…å·²çŸ¥ï¼‰
let z_idx = circuit.add_public_input(F::from(25u64));

// æ·»åŠ çº¦æŸï¼šx * x = xÂ²
let x_squared_idx = circuit.add_private_witness(F::from(9u64));
circuit.add_multiplication_constraint(x_idx, x_idx, x_squared_idx);
```

### 2. ä½¿ç”¨é¢„å®šä¹‰æ¨¡æ¿
```rust
// å¹³æ–¹æ ¹éªŒè¯ï¼šè¯æ˜ xÂ² = y
let circuit = CircuitTemplates::square_root_verification(x, y);

// èŒƒå›´è¯æ˜ï¼šè¯æ˜ x âˆˆ [min, max]
let circuit = CircuitTemplates::range_proof(value, min, max);

// äºŒæ¬¡æ–¹ç¨‹éªŒè¯ï¼šè¯æ˜ axÂ² + bx + c = 0
let circuit = CircuitTemplates::quadratic_equation_verification(a, b, c, x);
```

### 3. ç”µè·¯éªŒè¯
```rust
// éªŒè¯çº¦æŸæ˜¯å¦æ»¡è¶³
let is_valid = CircuitTester::test_circuit(&circuit);

// ä½¿ç”¨ PIOP è¿›è¡Œé›¶çŸ¥è¯†è¯æ˜
let mut checker = ConsistencyChecker::<F>::new();
let result = CircuitTester::run_piop_test(&circuit, &mut checker);
```

### 4. ä¿æŠ¤ç§æœ‰è§è¯
```rust
// ä½¿ç”¨ KZG æ‰¿è¯ºéšè—è§è¯
let kzg_scheme = KZGCommitmentScheme::<F, G1Projective>::setup(degree, &mut rng);
let witness_poly = DensePolynomial::from_coefficients_vec(witness_coeffs);
let commitment = kzg_scheme.commit(&witness_poly);
```

## ğŸ¯ è‡ªå®šä¹‰åœºæ™¯ç¤ºä¾‹

### åœºæ™¯ 1: èº«ä»½éªŒè¯ç”µè·¯
```rust
// è¯æ˜çŸ¥é“å¯†ç ä½†ä¸æ³„éœ²å¯†ç 
fn password_verification_circuit<F: PrimeField>(
    password_hash: F,
    known_password: F
) -> CustomCircuit<F> {
    let mut circuit = CustomCircuit::new("password_verification".to_string());
    
    // ç§æœ‰è§è¯ï¼šç”¨æˆ·è¾“å…¥çš„å¯†ç 
    let input_password_idx = circuit.add_private_witness(known_password);
    
    // å…¬å¼€è¾“å…¥ï¼šå­˜å‚¨çš„å¯†ç å“ˆå¸Œ
    let stored_hash_idx = circuit.add_public_input(password_hash);
    
    // è®¡ç®—è¾“å…¥å¯†ç çš„å“ˆå¸Œï¼ˆç®€åŒ–ï¼š3x + 1ï¼‰
    let computed_hash = F::from(3u64) * known_password + F::from(1u64);
    let computed_hash_idx = circuit.add_private_witness(computed_hash);
    
    // çº¦æŸï¼šè®¡ç®—çš„å“ˆå¸Œå¿…é¡»ç­‰äºå­˜å‚¨çš„å“ˆå¸Œ
    // è¿™é‡Œéœ€è¦æ›´å¤æ‚çš„çº¦æŸç³»ç»Ÿæ¥å¤„ç†ç­‰å¼éªŒè¯
    
    circuit
}
```

### åœºæ™¯ 2: å¹´é¾„è¯æ˜ç”µè·¯
```rust
// è¯æ˜å¹´é¾„ â‰¥ 18 ä½†ä¸æ³„éœ²å…·ä½“å¹´é¾„
fn age_proof_circuit<F: PrimeField>(age: F) -> CustomCircuit<F> {
    let mut circuit = CustomCircuit::new("age_proof".to_string());
    
    // ç§æœ‰è§è¯ï¼šå®é™…å¹´é¾„
    let age_idx = circuit.add_private_witness(age);
    
    // å…¬å¼€è¾“å…¥ï¼šæœ€å°å¹´é¾„è¦æ±‚
    let min_age_idx = circuit.add_public_input(F::from(18u64));
    
    // è¯æ˜ï¼šage - 18 â‰¥ 0
    let diff = age - F::from(18u64);
    let diff_idx = circuit.add_private_witness(diff);
    
    // ä½¿ç”¨å¹³æ–¹æ•°è¯æ˜éè´Ÿæ€§ï¼šdiffÂ² = diff Ã— diff
    let diff_squared_idx = circuit.add_private_witness(diff * diff);
    circuit.add_multiplication_constraint(diff_idx, diff_idx, diff_squared_idx);
    
    circuit
}
```

### åœºæ™¯ 3: è´¢äº§è¯æ˜ç”µè·¯
```rust
// è¯æ˜è´¢äº§æ€»é¢ > é—¨æ§›ä½†ä¸æ³„éœ²å…·ä½“æ•°é¢
fn wealth_proof_circuit<F: PrimeField>(
    assets: Vec<F>, 
    threshold: F
) -> CustomCircuit<F> {
    let mut circuit = CustomCircuit::new("wealth_proof".to_string());
    
    // ç§æœ‰è§è¯ï¼šå„é¡¹èµ„äº§
    let mut asset_indices = Vec::new();
    for asset in &assets {
        asset_indices.push(circuit.add_private_witness(*asset));
    }
    
    // å…¬å¼€è¾“å…¥ï¼šè´¢äº§é—¨æ§›
    let threshold_idx = circuit.add_public_input(threshold);
    
    // è®¡ç®—æ€»èµ„äº§
    let total_assets: F = assets.iter().sum();
    let total_idx = circuit.add_private_witness(total_assets);
    
    // è¯æ˜ï¼štotal - threshold > 0
    let excess = total_assets - threshold;
    let excess_idx = circuit.add_private_witness(excess);
    let excess_squared_idx = circuit.add_private_witness(excess * excess);
    
    circuit.add_multiplication_constraint(excess_idx, excess_idx, excess_squared_idx);
    
    circuit
}
```

## ğŸ”’ éšç§ä¿æŠ¤æœ€ä½³å®è·µ

1. **åˆ†ç¦»å…¬å¼€å’Œç§æœ‰æ•°æ®**
   - å…¬å¼€è¾“å…¥ï¼šéªŒè¯è€…å·²çŸ¥çš„ä¿¡æ¯
   - ç§æœ‰è§è¯ï¼šéœ€è¦ä¿æŠ¤çš„æ•æ„Ÿä¿¡æ¯

2. **ä½¿ç”¨ KZG æ‰¿è¯ºä¿æŠ¤è§è¯**
   ```rust
   let commitment = kzg_scheme.commit(&witness_polynomial);
   // åªå…¬å¼€æ‰¿è¯ºï¼Œä¸å…¬å¼€è§è¯å†…å®¹
   ```

3. **çº¦æŸç³»ç»Ÿè®¾è®¡**
   - ç¡®ä¿çº¦æŸèƒ½æ­£ç¡®è¡¨è¾¾æ‚¨çš„éªŒè¯é€»è¾‘
   - ä½¿ç”¨ä¹˜æ³•çº¦æŸæ„å»ºå¤æ‚é€»è¾‘
   - è€ƒè™‘çº¦æŸæ•°é‡å¯¹æ€§èƒ½çš„å½±å“

4. **é›¶çŸ¥è¯†è¯æ˜é›†æˆ**
   ```rust
   let mut checker = ConsistencyChecker::<F>::new();
   let piop_result = CircuitTester::run_piop_test(&circuit, &mut checker);
   ```

## ğŸš€ å¿«é€Ÿå¼€å§‹

1. **ä¿®æ”¹ `src/main.rs`** ä¸­çš„ `test_custom_circuit_and_witness()` å‡½æ•°
2. **åœ¨ `src/custom_circuits.rs`** ä¸­æ·»åŠ æ‚¨çš„ç”µè·¯æ¨¡æ¿
3. **è¿è¡Œ `cargo run`** æµ‹è¯•æ‚¨çš„ç”µè·¯
4. **æ£€æŸ¥çº¦æŸéªŒè¯ç»“æœ**ç¡®ä¿ç”µè·¯æ­£ç¡®æ€§

## ğŸ“Š æ€§èƒ½è€ƒè™‘

- **çº¦æŸæ•°é‡**ï¼šå½±å“è¯æ˜ç”Ÿæˆå’ŒéªŒè¯æ—¶é—´
- **è§è¯å¤§å°**ï¼šå½±å“é€šä¿¡å¼€é”€
- **ç”µè·¯æ·±åº¦**ï¼šå½±å“å¹¶è¡ŒåŒ–ç¨‹åº¦
- **å®‰å…¨çº§åˆ«**ï¼šå½±å“å¯†ç å­¦å‚æ•°é€‰æ‹©

## ğŸ›¡ï¸ å®‰å…¨æ€§æ³¨æ„äº‹é¡¹

- ç¡®ä¿çº¦æŸç³»ç»Ÿæ˜¯å®Œå¤‡çš„ï¼ˆæ²¡æœ‰é—æ¼çš„éªŒè¯ï¼‰
- éªŒè¯çº¦æŸç³»ç»Ÿæ˜¯å¯é çš„ï¼ˆä¸ä¼šæ¥å—æ— æ•ˆè¾“å…¥ï¼‰
- é€‰æ‹©åˆé€‚çš„å¯†ç å­¦å‚æ•°
- è€ƒè™‘æ—ä¿¡é“æ”»å‡»é˜²æŠ¤

---

ç°åœ¨æ‚¨å¯ä»¥æ ¹æ®è¿™ä¸ªæŒ‡å—åˆ›å»ºå±äºæ‚¨è‡ªå·±çš„è‡ªå®šä¹‰ç”µè·¯å’Œè§è¯ç³»ç»Ÿï¼
