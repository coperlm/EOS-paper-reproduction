# 🔧 EOS 自定义电路和见证指南

## 📍 文件位置
- **核心模块**: `src/custom_circuits.rs`
- **测试示例**: `src/main.rs` 中的 `test_custom_circuit_and_witness()` 函数

## 🛠️ 如何创建自定义电路

### 1. 基本电路创建
```rust
// 创建新电路
let mut circuit = CustomCircuit::<F>::new("我的电路".to_string());

// 添加私有见证（秘密输入）
let x_idx = circuit.add_private_witness(F::from(3u64));
let y_idx = circuit.add_private_witness(F::from(4u64));

// 添加公开输入（验证者已知）
let z_idx = circuit.add_public_input(F::from(25u64));

// 添加约束：x * x = x²
let x_squared_idx = circuit.add_private_witness(F::from(9u64));
circuit.add_multiplication_constraint(x_idx, x_idx, x_squared_idx);
```

### 2. 使用预定义模板
```rust
// 平方根验证：证明 x² = y
let circuit = CircuitTemplates::square_root_verification(x, y);

// 范围证明：证明 x ∈ [min, max]
let circuit = CircuitTemplates::range_proof(value, min, max);

// 二次方程验证：证明 ax² + bx + c = 0
let circuit = CircuitTemplates::quadratic_equation_verification(a, b, c, x);
```

### 3. 电路验证
```rust
// 验证约束是否满足
let is_valid = CircuitTester::test_circuit(&circuit);

// 使用 PIOP 进行零知识证明
let mut checker = ConsistencyChecker::<F>::new();
let result = CircuitTester::run_piop_test(&circuit, &mut checker);
```

### 4. 保护私有见证
```rust
// 使用 KZG 承诺隐藏见证
let kzg_scheme = KZGCommitmentScheme::<F, G1Projective>::setup(degree, &mut rng);
let witness_poly = DensePolynomial::from_coefficients_vec(witness_coeffs);
let commitment = kzg_scheme.commit(&witness_poly);
```

## 🎯 自定义场景示例

### 场景 1: 身份验证电路
```rust
// 证明知道密码但不泄露密码
fn password_verification_circuit<F: PrimeField>(
    password_hash: F,
    known_password: F
) -> CustomCircuit<F> {
    let mut circuit = CustomCircuit::new("password_verification".to_string());
    
    // 私有见证：用户输入的密码
    let input_password_idx = circuit.add_private_witness(known_password);
    
    // 公开输入：存储的密码哈希
    let stored_hash_idx = circuit.add_public_input(password_hash);
    
    // 计算输入密码的哈希（简化：3x + 1）
    let computed_hash = F::from(3u64) * known_password + F::from(1u64);
    let computed_hash_idx = circuit.add_private_witness(computed_hash);
    
    // 约束：计算的哈希必须等于存储的哈希
    // 这里需要更复杂的约束系统来处理等式验证
    
    circuit
}
```

### 场景 2: 年龄证明电路
```rust
// 证明年龄 ≥ 18 但不泄露具体年龄
fn age_proof_circuit<F: PrimeField>(age: F) -> CustomCircuit<F> {
    let mut circuit = CustomCircuit::new("age_proof".to_string());
    
    // 私有见证：实际年龄
    let age_idx = circuit.add_private_witness(age);
    
    // 公开输入：最小年龄要求
    let min_age_idx = circuit.add_public_input(F::from(18u64));
    
    // 证明：age - 18 ≥ 0
    let diff = age - F::from(18u64);
    let diff_idx = circuit.add_private_witness(diff);
    
    // 使用平方数证明非负性：diff² = diff × diff
    let diff_squared_idx = circuit.add_private_witness(diff * diff);
    circuit.add_multiplication_constraint(diff_idx, diff_idx, diff_squared_idx);
    
    circuit
}
```

### 场景 3: 财产证明电路
```rust
// 证明财产总额 > 门槛但不泄露具体数额
fn wealth_proof_circuit<F: PrimeField>(
    assets: Vec<F>, 
    threshold: F
) -> CustomCircuit<F> {
    let mut circuit = CustomCircuit::new("wealth_proof".to_string());
    
    // 私有见证：各项资产
    let mut asset_indices = Vec::new();
    for asset in &assets {
        asset_indices.push(circuit.add_private_witness(*asset));
    }
    
    // 公开输入：财产门槛
    let threshold_idx = circuit.add_public_input(threshold);
    
    // 计算总资产
    let total_assets: F = assets.iter().sum();
    let total_idx = circuit.add_private_witness(total_assets);
    
    // 证明：total - threshold > 0
    let excess = total_assets - threshold;
    let excess_idx = circuit.add_private_witness(excess);
    let excess_squared_idx = circuit.add_private_witness(excess * excess);
    
    circuit.add_multiplication_constraint(excess_idx, excess_idx, excess_squared_idx);
    
    circuit
}
```

## 🔒 隐私保护最佳实践

1. **分离公开和私有数据**
   - 公开输入：验证者已知的信息
   - 私有见证：需要保护的敏感信息

2. **使用 KZG 承诺保护见证**
   ```rust
   let commitment = kzg_scheme.commit(&witness_polynomial);
   // 只公开承诺，不公开见证内容
   ```

3. **约束系统设计**
   - 确保约束能正确表达您的验证逻辑
   - 使用乘法约束构建复杂逻辑
   - 考虑约束数量对性能的影响

4. **零知识证明集成**
   ```rust
   let mut checker = ConsistencyChecker::<F>::new();
   let piop_result = CircuitTester::run_piop_test(&circuit, &mut checker);
   ```

## 🚀 快速开始

1. **修改 `src/main.rs`** 中的 `test_custom_circuit_and_witness()` 函数
2. **在 `src/custom_circuits.rs`** 中添加您的电路模板
3. **运行 `cargo run`** 测试您的电路
4. **检查约束验证结果**确保电路正确性

## 📊 性能考虑

- **约束数量**：影响证明生成和验证时间
- **见证大小**：影响通信开销
- **电路深度**：影响并行化程度
- **安全级别**：影响密码学参数选择

## 🛡️ 安全性注意事项

- 确保约束系统是完备的（没有遗漏的验证）
- 验证约束系统是可靠的（不会接受无效输入）
- 选择合适的密码学参数
- 考虑旁信道攻击防护

---

现在您可以根据这个指南创建属于您自己的自定义电路和见证系统！
